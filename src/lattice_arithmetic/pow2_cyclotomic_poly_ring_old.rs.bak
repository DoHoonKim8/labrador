use std::array;
use std::cmp::Ordering;
use std::fmt::{Debug, Display, Formatter};
use std::hash::Hash;
use std::io::{Read, Write};
use std::iter::{Product, Sum};
use std::ops::{Add, AddAssign, Mul, MulAssign, Neg, Sub, SubAssign};

use ark_serialize::{CanonicalDeserialize, CanonicalDeserializeWithFlags, CanonicalSerialize, CanonicalSerializeWithFlags, Flags, SerializationError, Valid};
use ark_std::UniformRand;
use num_traits::{One, Zero};
use rand::Rng;
use zeroize::Zeroize;

use crate::lattice_arithmetic::poly_ring::PolyRing;
use crate::lattice_arithmetic::ring::Ring;

#[derive(Copy, Clone, Debug, Eq, PartialEq, Zeroize, Hash, CanonicalSerialize, CanonicalDeserialize)]
pub struct Pow2CyclotomicPolyRingNTT<BaseRing: Ring, const N: usize> {
    coeffs: [BaseRing; N],
}

impl<BaseRing: Ring, const N: usize> Pow2CyclotomicPolyRingNTT<BaseRing, N> {
    pub fn from_fn<F>(f: F) -> Self
        where F: FnMut(usize) -> BaseRing {
        Self { coeffs: array::from_fn(f) }
    }
    pub fn from_value(v: BaseRing) -> Self {
        Self { coeffs: [v; N] }
    }
}

impl<BaseRing: Ring, const N: usize> Ring for Pow2CyclotomicPolyRingNTT<BaseRing, N> {
    const ZERO: Self = Self { coeffs: [BaseRing::ZERO; N] };
    const ONE: Self = Self { coeffs: [BaseRing::ONE; N] };
}

impl<BaseRing: Ring, const N: usize> Default for Pow2CyclotomicPolyRingNTT<BaseRing, N> {
    fn default() -> Self {
        Self { coeffs: array::from_fn(|_| BaseRing::default()) }
    }
}

impl<BaseRing: Ring, const N: usize> Display for Pow2CyclotomicPolyRingNTT<BaseRing, N> {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        todo!()
    }
}

impl<BaseRing: Ring, const N: usize> Zero for Pow2CyclotomicPolyRingNTT<BaseRing, N> {
    fn zero() -> Self {
        Self::ZERO
    }

    fn is_zero(&self) -> bool {
        self.eq(&Self::ZERO)
    }
}

impl<BaseRing: Ring, const N: usize> Add<Self, > for Pow2CyclotomicPolyRingNTT<BaseRing, N> {
    type Output = Self;

    fn add(self, rhs: Self) -> Self::Output {
        todo!()
    }
}

impl<BaseRing: Ring, const N: usize> One for Pow2CyclotomicPolyRingNTT<BaseRing, N> {
    fn one() -> Self {
        todo!()
    }
}

impl<BaseRing: Ring, const N: usize> Mul<Self, > for Pow2CyclotomicPolyRingNTT<BaseRing, N> {
    type Output = Self;

    fn mul(self, rhs: Self) -> Self::Output {
        todo!()
    }
}

impl<BaseRing: Ring, const N: usize> Ord for Pow2CyclotomicPolyRingNTT<BaseRing, N> {
    fn cmp(&self, other: &Self) -> Ordering {
        todo!()
    }
}

impl<BaseRing: Ring, const N: usize> PartialOrd<Self> for Pow2CyclotomicPolyRingNTT<BaseRing, N> {
    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {
        todo!()
    }
}

impl<BaseRing: Ring, const N: usize> Neg<> for Pow2CyclotomicPolyRingNTT<BaseRing, N> {
    type Output = Self;

    fn neg(self) -> Self::Output {
        todo!()
    }
}

impl<BaseRing: Ring, const N: usize> UniformRand for Pow2CyclotomicPolyRingNTT<BaseRing, N> {
    fn rand<R: Rng + ?Sized>(rng: &mut R) -> Self {
        Self::from_fn(|_| BaseRing::rand(rng))
    }
}

impl<BaseRing: Ring, const N: usize> CanonicalSerializeWithFlags for Pow2CyclotomicPolyRingNTT<BaseRing, N> {
    fn serialize_with_flags<W: Write, F: Flags>(&self, writer: W, flags: F) -> Result<(), SerializationError> {
        todo!()
    }

    fn serialized_size_with_flags<F: Flags>(&self) -> usize {
        todo!()
    }
}

impl<BaseRing: Ring, const N: usize> CanonicalDeserializeWithFlags for Pow2CyclotomicPolyRingNTT<BaseRing, N> {
    fn deserialize_with_flags<R: Read, F: Flags>(reader: R) -> Result<(Self, F), SerializationError> {
        todo!()
    }
}

impl<BaseRing: Ring, const N: usize> Sub<Self, > for Pow2CyclotomicPolyRingNTT<BaseRing, N> {
    type Output = Self;

    fn sub(self, rhs: Self) -> Self::Output {
        todo!()
    }
}

impl<BaseRing: Ring, const N: usize> AddAssign<Self> for Pow2CyclotomicPolyRingNTT<BaseRing, N> {
    fn add_assign(&mut self, rhs: Self) {
        todo!()
    }
}

impl<BaseRing: Ring, const N: usize> SubAssign<Self> for Pow2CyclotomicPolyRingNTT<BaseRing, N> {
    fn sub_assign(&mut self, rhs: Self) {
        todo!()
    }
}

impl<BaseRing: Ring, const N: usize> MulAssign<Self> for Pow2CyclotomicPolyRingNTT<BaseRing, N> {
    fn mul_assign(&mut self, rhs: Self) {
        todo!()
    }
}

impl<'a, BaseRing: Ring, const N: usize> Add<&'a Self, > for Pow2CyclotomicPolyRingNTT<BaseRing, N> {
    type Output = Self;

    fn add(self, rhs: &'a Self) -> Self::Output {
        todo!()
    }
}

impl<'a, BaseRing: Ring, const N: usize> Sub<&'a Self, > for Pow2CyclotomicPolyRingNTT<BaseRing, N> {
    type Output = Self;

    fn sub(self, rhs: &'a Self) -> Self::Output {
        todo!()
    }
}

impl<'a, BaseRing: Ring, const N: usize> Mul<&'a Self, > for Pow2CyclotomicPolyRingNTT<BaseRing, N> {
    type Output = Self;

    fn mul(self, rhs: &'a Self) -> Self::Output {
        todo!()
    }
}

impl<'a, BaseRing: Ring, const N: usize> AddAssign<&'a Self> for Pow2CyclotomicPolyRingNTT<BaseRing, N> {
    fn add_assign(&mut self, rhs: &'a Self) {
        todo!()
    }
}

impl<'a, BaseRing: Ring, const N: usize> SubAssign<&'a Self> for Pow2CyclotomicPolyRingNTT<BaseRing, N> {
    fn sub_assign(&mut self, rhs: &'a Self) {
        todo!()
    }
}

impl<'a, BaseRing: Ring, const N: usize> MulAssign<&'a Self> for Pow2CyclotomicPolyRingNTT<BaseRing, N> {
    fn mul_assign(&mut self, rhs: &'a Self) {
        todo!()
    }
}

impl<'a, BaseRing: Ring, const N: usize> Add<&'a mut Self, > for Pow2CyclotomicPolyRingNTT<BaseRing, N> {
    type Output = Self;

    fn add(self, rhs: &'a mut Self) -> Self::Output {
        todo!()
    }
}

impl<'a, BaseRing: Ring, const N: usize> Sub<&'a mut Self, > for Pow2CyclotomicPolyRingNTT<BaseRing, N> {
    type Output = Self;

    fn sub(self, rhs: &'a mut Self) -> Self::Output {
        todo!()
    }
}

impl<'a, BaseRing: Ring, const N: usize> Mul<&'a mut Self, > for Pow2CyclotomicPolyRingNTT<BaseRing, N> {
    type Output = Self;

    fn mul(self, rhs: &'a mut Self) -> Self::Output {
        todo!()
    }
}

impl<'a, BaseRing: Ring, const N: usize> AddAssign<&'a mut Self> for Pow2CyclotomicPolyRingNTT<BaseRing, N> {
    fn add_assign(&mut self, rhs: &'a mut Self) {
        todo!()
    }
}

impl<'a, BaseRing: Ring, const N: usize> SubAssign<&'a mut Self> for Pow2CyclotomicPolyRingNTT<BaseRing, N> {
    fn sub_assign(&mut self, rhs: &'a mut Self) {
        todo!()
    }
}

impl<'a, BaseRing: Ring, const N: usize> MulAssign<&'a mut Self> for Pow2CyclotomicPolyRingNTT<BaseRing, N> {
    fn mul_assign(&mut self, rhs: &'a mut Self) {
        todo!()
    }
}

impl<BaseRing: Ring, const N: usize> Sum<Self> for Pow2CyclotomicPolyRingNTT<BaseRing, N> {
    fn sum<I: Iterator<Item=Self>>(iter: I) -> Self {
        todo!()
    }
}

impl<'a, BaseRing: Ring, const N: usize> Sum<&'a Self> for Pow2CyclotomicPolyRingNTT<BaseRing, N> {
    fn sum<I: Iterator<Item=&'a Self>>(iter: I) -> Self {
        todo!()
    }
}

impl<BaseRing: Ring, const N: usize> Product<Self> for Pow2CyclotomicPolyRingNTT<BaseRing, N> {
    fn product<I: Iterator<Item=Self>>(iter: I) -> Self {
        todo!()
    }
}

impl<'a, BaseRing: Ring, const N: usize> Product<&'a Self> for Pow2CyclotomicPolyRingNTT<BaseRing, N> {
    fn product<I: Iterator<Item=&'a Self>>(iter: I) -> Self {
        todo!()
    }
}

impl<BaseRing: Ring, const N: usize> From<u128> for Pow2CyclotomicPolyRingNTT<BaseRing, N> {
    fn from(value: u128) -> Self { Self::from_value(BaseRing::from(value)) }
}

impl<BaseRing: Ring, const N: usize> From<u64> for Pow2CyclotomicPolyRingNTT<BaseRing, N> {
    fn from(value: u64) -> Self { Self::from_value(BaseRing::from(value)) }
}

impl<BaseRing: Ring, const N: usize> From<u32> for Pow2CyclotomicPolyRingNTT<BaseRing, N> {
    fn from(value: u32) -> Self { Self::from_value(BaseRing::from(value)) }
}

impl<BaseRing: Ring, const N: usize> From<u16> for Pow2CyclotomicPolyRingNTT<BaseRing, N> {
    fn from(value: u16) -> Self { Self::from_value(BaseRing::from(value)) }
}

impl<BaseRing: Ring, const N: usize> From<u8> for Pow2CyclotomicPolyRingNTT<BaseRing, N> {
    fn from(value: u8) -> Self { Self::from_value(BaseRing::from(value)) }
}

impl<BaseRing: Ring, const N: usize> From<bool> for Pow2CyclotomicPolyRingNTT<BaseRing, N> {
    fn from(value: bool) -> Self { Self::from_value(BaseRing::from(value)) }
}

impl<BaseRing: Ring, const N: usize> Mul<BaseRing> for Pow2CyclotomicPolyRingNTT<BaseRing, N> {
    type Output = Self;

    fn mul(self, rhs: BaseRing) -> Self::Output {
        todo!()
    }
}

impl<BaseRing: Ring, const N: usize> PolyRing for Pow2CyclotomicPolyRingNTT<BaseRing, N> {
    type BaseRing = BaseRing;
    fn coeffs(&self) -> Vec<Self::BaseRing> {
        self.coeffs.iter().map(|v_i| BaseRing::from(*v_i)).collect()
    }
}